---
title: 1. 메모리와 값 (1)
date: 2024-02-07 02:08:00 +0900
categories: [초보를 위한 프로그래밍]
tags: []     # TAG names should always be lowercase
toc: true
comments: true
---

**프로그래밍**은 쉽게 말해서, <U>컴퓨터에게 일을 시키는 과정입니다</U>. 그렇다면 컴퓨터가 무엇인지 알아야 일을 시킬 수 있을 것입니다.

우리는 컴퓨터를 종종 '똑똑한 계산기'라고 하기도 합니다. 이 말에서 볼 수 있듯이, 컴퓨터의 본질은 계산기입니다. 그렇기에 컴퓨터에서 이루어지는 모든 작업을 끝까지 파고 들어가본다면 숫자에 대한 계산과 처리가 나올 수밖에 없습니다. 

그렇다면 어떻게 해야 계산과 처리를 할 수 있을까요. 우리 인간이 계산과 처리를 하는 과정을 생각해봅시다.

``` 1 + 2 ```

라는 수식이 있다고 생각해봅시다. 1 + 2를 계산하기 위해서, 우리는 왼쪽에서 오른쪽으로 글을 읽어갑니다. 

우리가 읽는 과정을 생각해봅시다.


처음으로 `1`을 읽었을 때, 아직까지는 계산이라고 부를 수 있는 단계가 아닙니다. 그러니까 다음으로 넘어갑시다.<br>
다음으로는 `+`를 읽게 됩니다. 우리는 이제 1에 <U>어떤 숫자를 더해야 한다</U>는 것을 알 수 있습니다.<br>
그리고 나서, `2`를 읽는다면 우리는 <U>1과 2를 더해</U> 3이라는 답을 내놓게 될 것입니다.

여기서 가장 중요한 것은, 우리가 `2`를 읽은 시점에서 `1`이라는 값을 <U>기억하고 있었다</U>는 것입니다. 1을 기억하지 않는다면, 2에 무엇을 더해야 하는지 알 수 없겠죠. 컴퓨터도 마찬가지입니다. 우리의 기억 장치가 뇌라면, 컴퓨터에서는 우리가 일상적으로 **메모리**, 혹은 **RAM**이라고 부르는 것이 기억 장치의 역할을 하게 됩니다.

우리는 숫자를 기억할 때, <U>0-9의 한 자리 숫자</U>를 기준으로 세어갑니다. `4`는 한 자리, `39`는 두 자리, `39800`은 다섯 자리인 것처럼요. 그러니까, 기수법<sup>[1)](#footnote_1)</sup>으로 **십진법 체계**를 사용한다고 할 수 있겠습니다. 

반면, 컴퓨터가 **이진법 체계**를 사용한다는 것은, 컴퓨터에 관심이 조금 있다면 알려진 상식 정도가 될 것입니다. 이진법은 <U>0과 1</U>만으로 숫자들을 표기하는 기수법입니다. 컴퓨터가 이진법을 사용하는 이유는 간단합니다. 그것이 가장 편리하기 때문이죠. 

컴퓨터는 전기로 작동하는 기계입니다. 앞서 말했던 메모리 역시 전기로 작동합니다. 그런 메모리에서, 이를테면, 십진법을 사용하려고 한다고 해 봅시다. 그렇다면 흐르는 전기의 세기를 <U>10단계로 조절</U>해야 할 것입니다. 그리고 그런 10단계의 전기 세기를 감지하기 위해서도 복잡한 과정이 필요하겠죠.

하지만, 이진법은 매우 간단히 작동합니다. <U>켜지면 1이고, 꺼지면 0</U>입니다. 10개의 세기를 나누어 감지할 필요도 없습니다. 이런 이유로 컴퓨터는 이진법을 사용합니다. 

우리가 십진법에서 숫자의 길이를 <U>몇 자리</U>와 같이 나타내듯이, 컴퓨터에서 이진법 숫자의 각 자리를 **비트**로 나타냅니다. `1000`은 4비트, `1101 0100`<sup>[2)](#footnote_2)</sup>은 8비트, 이런 식으로요. 

그러나 이진법에는 단점이 있습니다. 그것은 수를 표기하기 위해서는 너무 길어진다는 것이죠. 십진법에서의 `10`이 이진법으로는 `1010`입니다. `2024`는 `0111 1110 1000`로 나타내고요. `19721121` 정도가 되면 `0001 0010 1100 1110 1011 1010 0001`으로, 굉장히 긴 숫자가 되어버립니다. 이렇게 보이는 것이 길어지는 것도 문제지만, 계산 과정에서도 문제가 발생합니다.

큰 수를 더해본 기억은 누구나 있을 것입니다. 이때, 각 자리의 숫자의 합이 10을 넘어간다면 우리는 받아올림을 합니다. 이진법에서도 마찬가지로, 두 수를 더하는 과정에서 각 자리의 숫자의 합이 2(이진법으로는 `0b10`)를 넘어간다면 받아올림을 해야 하겠죠. 그런데 여기서 이진법은 각 자릿수가 1 아니면 0이기 때문에 받아올림이 십진법에서보다 훨씬 빈번해지게 됩니다. 또한 위에서 말한 것처럼 자릿수 자체도 늘어나기 때문에, 계산 과정도 복잡해지게 된다고 할 수 있겠죠. 

그래서, 컴퓨터는 비트 여러 개를 묶어서 **바이트**로 칭하고, 각각의 계산은 무조건 바이트 단위로 하게 됩니다. 일반적으로 바이트는 비트 8개를 묶어서 사용합니다. 그러니까, 하나의 바이트는 2<sup>8</sup>개, 즉 0-255까지의 수를 나타낼 수 있습니다. 일종의 256진법이라고 부를 수도 있겠네요.

<hr>

이제 다시 아까 이야기했던 메모리로 들어가봅시다. 메모리는 앞서 말했듯 기억 장치입니다. 그리고 그 기억 장치에 컴퓨터는 수를 바이트 단위로 저장합니다. 메모리라는 공간에 각 칸이 있는데, 그 칸이 바이트라고 비유해도 좋겠습니다. 그리고 각 칸을 구분하기 위해 숫자가 붙어 있는데, 이것을 주소라고 부릅니다.

<figure style="width: 80%; margin: 0 auto; margin-bottom: 10px; text-align: center; color: gray; font-weight: 600; font-size: 0.8em; line-spacing: 0.6em">
  <img src="/assets/img/memory1.png">
  <figcaption>
    그림으로 대강 나타낸 메모리. <small>뭐라고요? 1부터 시작한다고요?</small>
  </figcaption>
</figure>

이제 덧셈을 해 봅시다. 덧셈을 하려면 더할 두 개의 숫자가 필요합니다. 우리는 아까 그 숫자들이 이 문서에 써 있었지만, 컴퓨터 입장에서 보자면 메모리밖에 가진 게 없습니다. 그러니까, 메모리에 우리가 더할 숫자를 넣어주면 되겠습니다. 메모리의 1번지에 `0b01`을 넣고, 2번지에 `0b10`을 넣어줍시다. 십진법으로 따지면 각각 1과 2가 되겠죠.

<figure style="width: 80%; margin: 0 auto; margin-bottom: 10px; text-align: center; color: gray; font-weight: 600; font-size: 0.8em; line-spacing: 0.6em">
  <img src="/assets/img/memory2.png">
  <figcaption>
    이제 메모리엔 1과 2가 들어있습니다.
  </figcaption>
</figure>

다음은 덧셈을 시킬 차례입니다. 실제로 컴퓨터 내에서 덧셈이 어떻게 작동하는지는 우리가 알 필요가 없습니다. 아무리 저수준의 프로그래밍이라 하더라도, 덧셈 정도는 컴퓨터가 알아서 해 줍니다. 컴퓨터에서 실제로 덧셈을 진행하는 건 CPU인데, 우리가 여기에 명령을 내리면 컴퓨터가 해당하는 작업을 해 줄 것입니다. (어떻게 내리는지는 아마도 이 강좌의 범위를 벗어날 것입니다.)

CPU에 1번지와 2번지의 값을 더하라는 명령을 해 봅시다. 그럼 `0b01`과 `0b10`을 더해 `0b11`이라는 답이 나와야 합니다.

어라, CPU가 계산은 했는데 우리가 알 방법이 없습니다. 답이 나와야 하는데 컴퓨터에게 보이는 건 메모리뿐이니까요. 그러면, 쓰지 않았던 3번지에 연산의 결과를 저장하라고 해 봅시다.

<figure style="width: 80%; margin: 0 auto; margin-bottom: 10px; text-align: center; color: gray; font-weight: 600; font-size: 0.8em; line-spacing: 0.6em">
  <img src="/assets/img/memory3.png">
</figure>

드디어 컴퓨터에게서 1과 2를 더한 결과를 얻을 수 있었습니다. 

사실 방금은 컴퓨터에게 '뵈는 게 메모리밖에 없는' 것 처럼 묘사했지만, 실제로 그런 것은 아닙니다. 캐시 메모리, 레지스터 등의 다른 기억 장치라던가, 키보드로 문자를 입력하고 콘솔(화면)에 출력하는 등의 방법을 사용할 수도 있겠죠. 아니면 아예 HDD나 SSD같은 파일에 읽고 쓴다거나요.

다만, 프로그래밍을 하며 이루어지는 대부분의 과정은 메모리와 함께 이루어지는 것 역시 사실입니다. 그렇기에 우리는 프로그래밍을 하기 위해 최소한의 메모리에 대해서 알고, 또 그것을 실제 프로그래밍에도 적용할 수 있어야 합니다.

오늘의 글은 여기서 마치도록 하겠습니다. 감사합니다.

<hr>

<small><a name="footnote_1">1)</a> 숫자를 세는 방법을 의미합니다. 본 글에 나온 십진법과 이진법을 예시로 들면, 십진법은 0, 1, ..., 8, 9 총 10개의 숫자를 사용하여 수를 표기하기에 십진법이라 이름붙었습니다. 이진법은 마찬가지로 0, 1 두 개의 숫자만을 이용하기에 이진법이라 이름붙고요.<br><br>
프로그래밍을 하다 보면, 16진법도 자주 보게 될 것입니다. 십육진법은 0, 1, ..., 8, 9까지 십진법과 같이 가다가, 10-15까지의 수를 나타내기 위해 a, b, c, d, e, f라는 숫자를 사용합니다. 그러니까, 10진법의 27은, 16진법으로 1B로 표기됩니다.<br><br>
이진법이든 십진법이든 16진법이든, 모두 공통적으로 포함되는 숫자들이 있기에 혼동의 여지가 있습니다. 이를 좀 더 명확히 하기 위해 앞에 접두어를 붙여 표기합니다. 이진법은 `0b1010`, 십육진법은 `0x3f9a`, 그리고 자주 쓰이지는 않지만 8진법은 `0o3201`와 같은 식으로요. 십진법에는 접두어가 따로 없습니다. 그러므로 이제부터 접두어가 붙어있지 않은 숫자가 보인다면, 기본적으로 십진법이라고 생각하셔도 무방하겠습니다.</small>

<small><a name="footnote_2">2)</a> 숫자의 길이가 너무 길어져서, 네 자리씩 끊어서 표기했습니다. 3980000을 3,980,000으로 끊어 표기하는 것과 비슷하게 생각하시면 됩니다.</small>